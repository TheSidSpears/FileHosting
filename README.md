Реализовать
-борьба с загрузкой HTML-файла: можно загружать файлы на отдельный от основного домен, можно при скачивании выставлять правильные заголовки, которые заставят браузер скачать файл, а не открыть его как веб-страницу (Content-Disposition: attachment, Content-Type не содержащий text/html)


-переименовывание обратно из name в original_name при отгрузке файла пользователю
-админская кнопка удалить файл
-описание файла: кол-во скачиваний
-numberOfDownloads при создании файла по умолчанию 0

Реализую загрузку файлов с сервера. Сейчас у меня так: показать download.html с Location -> location перенаправляет на файл и он открывается в браузере.
Хочу: ф-ия возвращает не проходной и ненужный download.html, а сразу файл, в http Header которого будет прописан 'Content-Disposition':'attachment' И который будет загружаться.

Как это можно реализовать? 


разу посоветую получение пути к файлу вынести в отдельный метод.

Также, если ты выдаешь заголовок location, то непонятно зачем рендерить download.html, так как пользователь эту страницу скорее всего не увидит.

Также, заголовок content-dispoistion должен отдаваться не со страницей, а вместе с файлом. У тебя же (если убрать location) он приведет к тому что браузер сохранит саму HTML страницу.

> Хочу: ф-ия возвращает не проходной и ненужный download.html, а сразу файл, в http Header которого будет прописан 'Content-Disposition':'attachment' И который будет загружаться.
> Как это можно реализовать?

Ну самый простой способ это прочитать file_get_contents файл в переменную и вывести через усрщ (после заголовков). Но это требует загрузить файл целиком в память, а echo не совсем соответствует идеям Слима.

Вот тут http://www.slimframework.com/docs/objects/response.html#the-response-body написано как можно задать, чтобы тело ответа читалось бы из файла постепенно.

Ну и если еще оптимизировать, то хорошо бы отдавать файлы без особого участия PHP. Для этого надо настроить веб-сервер, например в случае Апача можно использовать расширение X-Sendfile. С ним PHP только отдает заголовок с именем файла и завершается, а веб-сервер уже дальеш отдает файл. Или пойти еще дальше и настроить правила в .htaccess так, чтобы файл отдавался по ссылке сразу вообще без обращения к PHP.





Я практически ничего не вынес из твоего ответа, поэтому начнём с малого.
Есть код http://ideone.com/B77xqx . Из него нужно убрать $this->view->render($response, 'download.html', $args), потому что мне вообще не нужно никакую web-страницу возвращать. во всех примерах в get в return прописано рендерить страницу, и я не знаю как туда можно прописать что-то еще
А возвращать он должен файл (бог с ней, с закачкой пока)

Как? 





> о всех примерах в get в return прописано рендерить страницу
Надо не только смотреть примеры, а надо разбираться как именно работает фреймворк. Ты не обязан вызывать render, и нигде такого не написано. Обработчик просто должен сформировать HTTP-ответ в объекте $response и вернуть его.

Также, надо немного представлять как работает протокол HTTP.

Вот теперь подумай, какой HTTP-ответ должен получиться и как его сформировать в объекте $response. То есть надо задать нужные заголовки (как минимум задающие тип содержимого и то, что это файл для скачивания), а в качестве тела ответа передать содержимое файла.

Изучи код или документацию объекта Response в Слиме.

В моем посте было написано несколько вариантов, как это сделать, начиная с наименее оптимального способа.

Есть есть еще какие-то конкретные вопросы, задавай.










Веб-сервер раскодирует процентную кодировку автоматически при поиске файла. Насчет плюса - не уверен.

Что касается кириллицы - надо быть осторожным, кодировка в URL должна совпадать с используемой кодировкой в файловой системе (в линуксе это обычно utf-8, в винде win-1251). То есть кирилицу в именах файлов на диске лучше вообще не использовать, даже вместе с процентным кодированием.

Вообще, чтобы не мучаться с именами, лучше сделать так: давать файлам на диске простые имена (только латиница и цифры например). А URL для них делать такой:

http://example.com/download/file123.txt/скачиваемое-имя.php

СОответственно в htaccess мы приписываем правило чтобы такой УРЛ перенаправлялся на файл

/download/file123.txt

А последняя часть в УРЛ нужна для того, чтобы браузер взял из нее нужное имя для сохранения файла.

Также, есть еще вариант с X-sendfile. Это расширение Апача которое может само отдавать файлы (в том числе из непублинчых папок). Там схема такая: запрос поступает к php, который определяет реальное имя файла, отдает апачу заголовок с ним и завершается. А Апач уже отдает этот файл.

То есть в таком сценарии можно сделать например УРЛ

/download/1234/имя-для-скачивания.txt

А файл реально хранится где-то в /storage/1234-some-name.txt

В любом случае принцип тут такой: браузер берет в качестве имени последний сегмент в УРЛ (то что идет от последнего слеша до конца УРЛ), при этом хранить файл мы можем под другим именем. Но в этом случае мы должны придумать механизм, как получить это настоящее имя из УРЛ. Либо оно как-то там заложено, либо там заложен id файла, а имя мы берем из базы.

При выборе имени для хранения на диске надо учесть такие моменты:

- скачиваемый файл хорошо бы сохранять с тем же именем что и закачиваемый
- разные пользователи могут загрузить 2 файла с одинаковым именем, и надо чтобы они не затерли друг друга
- если мы сохраним файл с именем x.php на диск то есть риск его выполнения. То же самое относится к файлам с именами .htaccess которые позволяют переопределить настройки сервера. Значит, нам надо гарантировать сохранение на диск с безопасным расширением
- если использовать имена в кирилице, может возникнуть проблема с тем, что в УРЛ используется utf-8, а на диске (в винде например) - другая кодировка
- желательно распределять файлы по папкам, чтобы в одной папке было не более 1000 файлов, а то трудно будет оиентироваться
- желательно делать понятные имена на диске, чтобы администратору было проще разбираться, есть что

Попробуй придумать схему, которая бы удовлетворяла этим критериям. Ну и конечно не забудь про безопасность.